//
// Implements page table entry (PTE) management for the xr17032 architecture.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OSStatus.h"

#include "../MmInternal.h"

fn MmVirtualtoPTEAddress { vaddr -- pteaddr }
	// get the address of a PTE based on a vaddr.

	if (DEBUGCHECKS)
		if (vaddr@ MMLOWESTSYSTEMADDRESS <)
			vaddr@ "MmVirtualtoPTEAddress: used on user address 0x%08x\n" KeCrash
		end
	end

	vaddr@ PAGESHIFT >> 2 << PAGETABLE + pteaddr!
end

extern HALI386TLBFlush { vaddr -- }

fn MiPTEUpdate { phyaddr flags pteaddr -- oldphyaddr oldflags }
	// update a PTE based on a physical address and generic flags. this could
	// do a number of things:

	auto pte
	pteaddr@@ pte!

	pte@ 127 & oldflags!
	pte@ 12 >> PAGESHIFT << oldphyaddr!

	if (pteaddr@ PAGETABLE < pteaddr@ PAGETABLETOP >= ||)
		phyaddr@ PAGESHIFT >> 12 << flags@ 127 & | pteaddr@!
		return
	end

	auto vaddr
	pteaddr@ PAGETABLE - 2 >> PAGESHIFT << vaddr!

	if (vaddr@ MMLOWESTSYSTEMADDRESS <)
		// this is a user page.

		if (flags@ PTE_V &)
			PTE_U flags |=
		end
	end

	phyaddr@ PAGESHIFT >> 12 << flags@ 127 & | pte!

	pte@ pteaddr@!

    if (oldflags@ 1 &)
	    vaddr@ HALI386TLBFlush
    end
end

fn MiPTEUpdateByVirtual { phyaddr flags vaddr -- oldphyaddr oldflags }
	auto pteaddr
	vaddr@ PAGESHIFT >> 2 << PAGETABLE + pteaddr!

	phyaddr@ // phyaddr
	flags@ // flags
	pteaddr@ // pteaddr
	MiPTEUpdate oldflags! oldphyaddr!
end

fn MiPTEInterpret { pteaddr -- phyaddr flags ok }
	// interpret arch-specific PTE contents into physical address and generic
	// flags. returns -1 if the PTE is not valid.

	0 ok!

	auto pte
	pteaddr@@ pte!

	if (pte@ PTE_V & ~~)
		0 flags!
		-1 ok!
		return
	end

	// i386 PTEs happen to line up with the generic PTE flags, so
	// just mask those off and return them directly.
	pte@ 127 & flags!
	pte@ 12 >> PAGESHIFT << phyaddr!
end

fn MiPTEIsZero { pte -- iszero }
	if (pte@ ~~)
		1 iszero!
	end elseif (pte@ PTE_KERNEL_ZERO ==)
		1 iszero!
	end else
		0 iszero!
	end
end

fn MmVirtualToPhysical { vaddr -- phyaddr }
	auto pte
	vaddr@ PAGESHIFT >> 2 << PAGETABLE + @ pte!

	if (DEBUGCHECKS)
		if (pte@ PTE_V & ~~)
			"MmVirtualToPhysical: invalid PTE\n" KeCrash
		end
	end

	pte@ 12 >> PAGESHIFT << phyaddr!

	vaddr@ PAGEOFFSETMASK & phyaddr +=
end

fn MmVirtualToPFDBE { vaddr -- pfdbe }
	auto pte
	vaddr@ PAGESHIFT >> 2 << PAGETABLE + @ pte!

	if (DEBUGCHECKS)
		if (pte@ PTE_V & ~~)
			"MmVirtualToPFDBE: invalid PTE\n" KeCrash
		end
	end

	pte@ 12 >> MiPageFrameEntry_SIZEOF * MiPageFrameDatabase@ + pfdbe!
end

fn MiPTESet { pte pteaddr -- }
	if (pteaddr@ PAGETABLE < pteaddr@ PAGETABLETOP >= ||)
		pte@ pteaddr@!
		return
	end

	auto vaddr
	pteaddr@ PAGETABLE - 2 >> PAGESHIFT << vaddr!

	if (vaddr@ MMLOWESTSYSTEMADDRESS <)
		// this is a user page.
		if (pte@ PTE_V &)
			PTE_U pte |=
		end
	end

	pte@ pteaddr@!

	vaddr@ HALI386TLBFlush
end

fn MiPTESetDirty { pteaddr -- }
	pteaddr@@ PTE_D | // pte
	pteaddr@ // pteaddr
	MiPTESet
end

fn MiPTEPin { vaddr -- ptpfdbe pteaddr }
	// pin the page table containing the PTE for the given virtual address,
	// and return the PTE address.

	vaddr@ PAGESHIFT >> 2 << PAGETABLE + pteaddr!

	if (vaddr@ PAGETABLE >= vaddr@ SYSPAGETABLE < &&)
		pteaddr@ MmVirtualToPFDBE ptpfdbe!

		return
	end

	auto ptecount
	auto pfdbe
	auto ptr

	auto pdeaddr
	vaddr@ 22 >> 2 << PAGEDIRECTORY + pdeaddr!

	while (1)
		// loop until the page table is valid.

		auto ipl
		IPLDPC KeIPLRaise ipl!

		auto pde
		pdeaddr@@ pde!

		if (pde@ ~~)
			// no such page table.

			ipl@ KeIPLLower

			0 ptpfdbe!

			return
		end elseif (pde@ PTE_V &)
			// the page table is valid. pin it and return it.

			pde@ 12 >> MiPageFrameEntry_SIZEOF * MiPageFrameDatabase@ + ptpfdbe!

			ptpfdbe@ MmEvictablePageReference drop
			1 ptpfdbe@ MiPageFrameEntryPageTable_HoldCount + +=

			ipl@ KeIPLLower

			return
		end else
			ipl@ KeIPLLower

			// the page table is invalid. touch it to cause it to be demand-
			// -paged in.

			auto probe
			pteaddr@@ probe!
		end
	end
end

fn MiPTECreate { vaddr -- pteaddr ok }
	// create an empty PTE for the vaddr in the current process.
	// if the page table exists, it is referenced. otherwise it is created and
	// initialized with a refcount of 1.
	// assumes VAD list mutex is held.

	vaddr@ PAGESHIFT >> 2 << PAGETABLE + pteaddr!

	0 ok!

	auto process
	KeProcessCurrent process!

	auto pagemap
	process@ KeProcess_PageDirectory + @ 12 >> PAGESHIFT << pagemap!

	auto ptecount
	auto pfdbe
	auto ptr

	auto pdeaddr
	vaddr@ 22 >> 2 << PAGEDIRECTORY + pdeaddr!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto pde
	pdeaddr@@ pde!

	if (pde@ ~~)
		// need to allocate this page table.

		ipl@ KeIPLLower

		0 // pri
		vaddr@ // vaddr
		process@ // process
		MiProcessPTECountGet ok! ptecount!

		if (ok@)
			return
		end

		// private page prototype PTEs are physical addresses.

		pagemap@ vaddr@ 22 >> 2 << + // pte
		ZEROMUST // priority
		MiAnonymousPageAlloc pfdbe!

		1 ptecount@ si
		ptecount@ pfdbe@ MiPageFrameEntryPageTable_PTECountTableEntry + !
		0 pfdbe@ MiPageFrameEntryPageTable_HoldCount + !

		pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE |
		pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + sb

		// create a transition PTE so we can fault this new page table in.

		pfdbe@ MmPFDBEToPhysicalAddress PTE_TRANSITION | pdeaddr@!

		pagemap@ PAGESHIFT >> MiPageFrameEntry_SIZEOF * MiPageFrameDatabase@ +
		MmEvictablePageReference drop

		// put the PTE in the process's working set by probing it.

		auto probe
		pteaddr@@ probe!

		if (DEBUGCHECKS)
			if (pteaddr@ MmVirtualAddressIsValid ~~)
				probe@ pteaddr@ "MiPTECreate: invalid pteaddr %x %x\n" KeCrash
			end

			if (pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi 2 ~=)
				pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi "MiPTECreate: wrong refcount %d\n" KeCrash
			end
		end
	end else
		if (DEBUGCHECKS)
			if (pde@ PTE_V & ~~)
				"MiPTECreate: PDE not valid\n" KeCrash
			end
		end

		pde@ 12 >> MiPageFrameEntry_SIZEOF * MiPageFrameDatabase@ + pfdbe!

		if (DEBUGCHECKS)
			if (pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi ~~)
				"MiPTECreate: page table had no references\n" KeCrash
			end
		end

		pfdbe@ MiPageFrameEntryPageTable_PTECountTableEntry + @ gi 1 +
		pfdbe@ MiPageFrameEntryPageTable_PTECountTableEntry + @ si

		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		pfdbe@ // pfdbe
		0 // process
		MmEvictablePageModify
	end
end
