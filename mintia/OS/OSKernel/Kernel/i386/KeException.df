#include "<df>/dragonfruit.h"
#include "<inc>/HALCrash.h"

#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALConsole.h"

#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

#include "../KeInternal.h"
#include "../../../OSLoader/OSLoaderGlobal.h"

struct Tss
    4 Previous
    4 esp0
    4 ss0
    4 esp1
    4 ss1
    4 esp2
    4 ss2
    4 cr3
    4 eip
    4 eflags
    4 eax
    4 ecx
    4 edx
    4 ebx
    4 esp
    4 ebp
    4 esi
    4 edi
    4 es
    4 cs
    4 ss
    4 ds
    4 fs
    4 gs
    4 ldt
    2 trapI
    2 IOMapBaseI
endstruct

externptr KiI386Gdt

buffer KiI386Tss Tss_SIZEOF
public KiI386Tss

const GDT_SEL_KCODE 0x08
const GDT_SEL_KDATA 0x10
const GDT_SEL_UCODE 0x1b
const GDT_SEL_UDATA 0x23
const GDT_SEL_UTEB  0x2b
const GDT_SEL_TASK  0x30
const GDT_SIZE      0x38

table Idt[(VECTOR_NUM 2 *)]

externptr KiI386IdtThunks

extern KiI386Init { tr gdtr idtr code data -- }

fn KiCPUInit { -- }
    fnsection "INIT$text"

    // create tss
    GDT_SEL_KDATA KiI386Tss Tss_ss0 + !
    Tss_SIZEOF KiI386Tss Tss_IOMapBaseI + si

    KiI386Tss 16 << Tss_SIZEOF 1 - | KiI386Gdt GDT_SEL_TASK + !
    KiI386Tss 0xff000000 & KiI386Tss 16 >> 0xff & | 0x8900 | KiI386Gdt GDT_SEL_TASK 4 + + !

    // create idt
    auto i
    0 i!

    while (i@ VECTOR_NUM <)
        auto thunk
        [i@]KiI386IdtThunks@ thunk!

        if (thunk@)
            thunk@ 0xffff & GDT_SEL_KCODE 16 << | [i@ 2 *]Idt!
            thunk@ 0xffff0000 & 0x8e00 | [i@ 2 * 1 +]Idt!
        end

        1 i +=
    end

    // allow userspace to call interrupt 0x30
    0x6000 [VECTOR_SYSCALL 2 * 1 +]Idt |=

    // create gdtr and idtr
    GDT_SIZE 1 - KiI386Gdt!
    KiI386Gdt KiI386Gdt 2 + !

    auto idtr
    6 alloc idtr!
    VECTOR_NUM 8 * 1 - idtr@!
    Idt idtr@ 2 + !

    // set all the cpu registers
    GDT_SEL_TASK KiI386Gdt idtr@ GDT_SEL_KCODE GDT_SEL_KDATA KiI386Init
end

const VECTOR_DE      0x00
const VECTOR_DB      0x01
const VECTOR_NMI     0x02
const VECTOR_BP      0x03
const VECTOR_OF      0x04
const VECTOR_BR      0x05
const VECTOR_UD      0x06
const VECTOR_NM      0x07
const VECTOR_DF      0x08
const VECTOR_CS      0x09
const VECTOR_TS      0x0a
const VECTOR_NP      0x0b
const VECTOR_SS      0x0c
const VECTOR_GP      0x0d
const VECTOR_PF      0x0e
const VECTOR_MF      0x10
const VECTOR_AC      0x11
const VECTOR_SYSCALL 0x30
const VECTOR_NUM     0x31

const EXCNAMESMAX 0x12

table ExceptionNames
    "#DE"
    "#DB"
    "NMI"
    "#BP"
    "#OF"
    "#BR"
    "#UD"
    "#NM"
    "#DF"
    "#CS"
    "#TS"
    "#NP"
    "#SS"
    "#GP"
    "#PF"
    0
    "#MF"
    "#AC"
endtable

const PF_WRITE 0x02

extern PsDispatchUsermodeInterrupts { trapframe -- }

externptr KeIPLCurrent

extern KiI386Syscall { tf -- }

fn KiI386Trap { cr2 tf -- }
	auto handled
	1 handled!

	auto signal
	0 signal!

	cr2@ tf@ OSContext_cr2 + !
	KeIPLCurrent@ KiOldIPL!

	if (tf@ OSContext_cs + @ I386_CS_USER &)
		tf@ KeThreadCurrent@ KeThread_TrapFrame + !
	end

    auto vector
    tf@ OSContext_vector + @ vector!

	0 handled!

	if (vector@ 0x20 >= vector@ 0x2f <= &&)
		1 KeStatistics OSStatistics_Interrupts + +=

		tf@ HALInterrupt

		if (KeIPLCurrent@ IPLDPC <)
			if (KiPendingSoftwareInterrupts@)
				KiDispatchSoftwareInterrupts
			end
		end

		0 signal!
		1 handled!
	end elseif (vector@ VECTOR_NMI ~=)
		HALCPUInterruptEnable

		if (vector@ VECTOR_SYSCALL ==)
			1 KeStatistics OSStatistics_SystemCalls + +=

			tf@ KiI386Syscall

			1 handled!
		end elseif (vector@ VECTOR_PF ==)
			tf@ OSContext_error + @ PF_WRITE & ~~ ~~ // writing
			cr2@ // badaddr
			tf@ // trapframe
			MmPageFault handled!
        end elseif (vector@ VECTOR_DE ==)
            OSSIGNAL_FPE signal!
        end elseif (vector@ VECTOR_OF ==)
            OSSIGNAL_ILL signal!
        end elseif (vector@ VECTOR_BR ==)
            OSSIGNAL_ILL signal!
		end elseif (vector@ VECTOR_UD ==)
			OSSIGNAL_ILL signal!
		end elseif (vector@ VECTOR_NM ==)
			OSSIGNAL_ILL signal!
        end elseif (vector@ VECTOR_CS ==)
            OSSIGNAL_ILL signal!
        end elseif (vector@ VECTOR_TS ==)
            OSSIGNAL_ILL signal!
        end elseif (vector@ VECTOR_NP ==)
            OSSIGNAL_ILL signal!
        end elseif (vector@ VECTOR_SS ==)
            OSSIGNAL_ILL signal!
        end elseif (vector@ VECTOR_GP ==)
            OSSIGNAL_ILL signal!
        end elseif (vector@ VECTOR_MF ==)
            OSSIGNAL_FPE signal!
		end elseif (vector@ VECTOR_AC ==)
			OSSIGNAL_BUS signal!
		end elseif (vector@ VECTOR_BP == vector@ VECTOR_DB == ||)
			1 handled!
			// TODO debugging stuff
		end

		if (signal@)
			if (tf@ OSContext_cs + @ I386_CS_USER &)
				signal@ // signal
				KeThreadCurrent@ // thread
				KeThreadSignal drop

				1 handled!
			end
		end

		HALCPUInterruptDisable drop
	end

	if (handled@ ~~)
		auto excname

		if (vector@ EXCNAMESMAX >)
			"UNKNOWN" excname!
		end else
			[vector@]ExceptionNames@ excname!

            if (excname@ ~~)
                "UNKNOWN" excname!
            end
		end

		if (vector@ VECTOR_NMI ==)
			if (HALDebug)
				return
			end

			return
		end

		excname@
		cr2@
		tf@ OSContext_eip + @
		tf@ OSContext_cs + @
		KeIPLCurrent@
		"Fault: IPL=%d CS=%04x EIP=%08x CR2=%08x VECTOR=%s\n" KeCrash
	end

	if (tf@ OSContext_cs + @ I386_CS_USER &)
		if (KeThreadCurrent@ KeThread_UserInterruptB + gb)
			tf@ PsDispatchUsermodeInterrupts
		end
	end
end

fn HALCPUContextInit { context1 context2 startfunc kstack process -- ctx }
    kstack@ OSContext_SIZEOF 12 + - ctx!

    ctx@ OSContext_SIZEOF 0 memset

    startfunc@ ctx@ OSContext_ebx + !
    context1@ ctx@ OSContext_esi + !
    context2@ ctx@ OSContext_edi + !

    pointerof KiThreadTrampoline ctx@ OSContext_SIZEOF 8 + + !
end

extern HALI386MapSwitch { pgtb -- }

fn KeAddressSpaceSwitch { process -- }
	auto rs
	HALCPUInterruptDisable rs!

	if (process@ KeProcess_PageDirectory + @ HALPlatformKernelPageDirectory@ ==)
		HALPlatformKernelPageDirectory@ // pgtb
		HALI386MapSwitch
	end else
		process@ KeProcess_PageDirectory + @ 12 >> PAGESHIFT << // pgtb
		HALI386MapSwitch
	end

    rs@ HALCPUInterruptRestore
end

fn HALCPUIsUserTrapFrame { tf -- user }
	tf@ OSContext_cs + @ I386_CS_USER & user!
end

extern KiContinue { tf -- }

fn KeEnterUserMode { teb exitfunc context ustack entryfunc -- }
    // set up teb segment

    teb@ 16 << 0xffff | KiI386Gdt GDT_SEL_UTEB 3 ~ & + !
    teb@ 0xff000000 & teb@ 16 >> 0xff & | 0xcff300 | KiI386Gdt GDT_SEL_UTEB 3 ~ & 4 + + !

    // make a fake trap frame to return to

    auto tf
    OSContext_SIZEOF alloc tf!

	tf@ // ptr
	OSContext_SIZEOF // sz
	0 // word
	memset

    exitfunc@ tf@ OSContext_eax + !
    context@ tf@ OSContext_edx + !
    entryfunc@ tf@ OSContext_ecx + !
    GDT_SEL_UDATA tf@ OSContext_ds + !
    GDT_SEL_UDATA tf@ OSContext_es + !
    GDT_SEL_UTEB tf@ OSContext_fs + !
    GDT_SEL_UDATA tf@ OSContext_gs + !
    PsOSDLLInformation PsOSDLLInfo_ThreadEntryFunction + @ tf@ OSContext_eip + !
    GDT_SEL_UCODE tf@ OSContext_cs + !
    2 tf@ OSContext_eflags + !
    ustack@ tf@ OSContext_esp + !
    GDT_SEL_UDATA tf@ OSContext_ss + !

	HALCPUInterruptDisable drop

	if (KeThreadCurrent@ KeThread_UserInterruptB + gb)
		tf@ PsDispatchUsermodeInterrupts
	end

	tf@ KiContinue
end

fn KiInterruptUsermode { context userfunc dispatchfunc trapframe -- }
	// Cause a usermode interrupt of the current thread by saving the context
	// on the user stack and redirecting the trapframe to the usermode
	// interrupt handler. This is used to implement signal and APC dispatch.

	auto usp
	trapframe@ OSContext_esp + @ usp!

	if (DEBUGCHECKS)
		if (trapframe@ OSContext_cs + @ I386_CS_USER & ~~)
			trapframe@ "KiInterruptUsermode: not usermode trapframe %x\n" KeCrash
		end
	end

	OSContext_SIZEOF usp -=

	auto ok
	usp@ // dest
	trapframe@ // src
	OSContext_SIZEOF // sz
	KeSafeCopyOut ok!

	if (ok@)
		// Failed to copy out context frame, this is fatal to the entire
		// process.

		// TODO automatically switch to an overflow stack?

		OSSIGNAL_KILL // signal
		KeThreadCurrent@ KeThread_Process + @ // process
		KeProcessSignal drop

		return
	end

	// Redirect the trapframe to the usermode interrupt handler.

	usp@ trapframe@ OSContext_esp + !
	dispatchfunc@ trapframe@ OSContext_eip + !
	context@ trapframe@ OSContext_eax + !
	userfunc@ trapframe@ OSContext_edx + !
end

fn KeThreadContinue { alertable signum context thread -- ok }
	// Restore context and continue out of a usermode interrupt handler.

	if (signum@ -1 ~=)
		if (signum@ ~~)
			STATUS_INVALID_ARGUMENT ok!

			return
		end

		if (signum@ 32 >=)
			STATUS_INVALID_ARGUMENT ok!

			return
		end
	end

	0 ok!

	auto tf
	thread@ KeThread_TrapFrame + @ tf!

	auto cs
	tf@ OSContext_cs + @ cs!

	if (DEBUGCHECKS)
		if (cs@ I386_CS_USER & ~~)
			tf@ "KeThreadContinue: not usermode trapframe %x\n" KeCrash
		end
	end

	tf@ // dest
	context@ // src
	OSContext_SIZEOF // size
	memcpy

	// don't modify segments to prevent privilege escalations and faults
	GDT_SEL_UCODE tf@ OSContext_cs + !
	GDT_SEL_UDATA tf@ OSContext_ds + !
	GDT_SEL_UDATA tf@ OSContext_es + !
	GDT_SEL_UTEB tf@ OSContext_fs + !
	GDT_SEL_UDATA tf@ OSContext_gs + !
	GDT_SEL_UDATA tf@ OSContext_ss + !

	// ensure we don't set iopl, vm86, vif, or vip, and that we set if
	tf@ OSContext_eflags + @ 0x1a3000 ~ & 0x200 | tf@ OSContext_eflags + !

	auto rs
	HALCPUInterruptDisable rs!

	if (signum@ -1 ~=)
		// atomically unmask the signal.

		1 signum@ << thread@ KeThread_SignalAcceptMask + |=

		if (thread@ KeThread_SignalAcceptMask + @
			thread@ KeThread_SignalDeliverOnWaitMask + @ ~ &
			thread@ KeThread_Signals + @ &)

			1 thread@ KeThread_UserInterruptB + sb
		end
	end

	if (alertable@)
		// check for another user APC to deliver, so that they "chain"
		// properly.

		if (thread@ KeThread_UserAPCListHead + @)
			1 thread@ KeThread_UserAPCTriggeredB + sb
			1 thread@ KeThread_UserInterruptB + sb
		end
	end

	// Perform a direct return to avoid corrupting the newly-built trapframe
	// on our way out from the syscall handler, and to make sure we can't
	// miss any user APCs that get enqueued after we return.

	if (thread@ KeThread_UserInterruptB + gb)
		tf@ PsDispatchUsermodeInterrupts
	end

	tf@ KiContinue
end

fn HALCPUTrapFrameAbort { ok abort tf -- }
	ok@ tf@ OSContext_eax + !
	abort@ tf@ OSContext_eip + !
end
