//
// Implements the PC-specific part of bootloader initialization.
//

#include "<df>/dragonfruit.h"

#include "../OSLoader.h"

buffer LdrArgsBuffer 256
public LdrArgsBuffer

var LdrPlatformHALName 0
public LdrPlatformHALName

fn private ArgsInit { argp -- }
	auto p
	LdrArgsBuffer p!

	auto l
	0 l!

	auto esc
	0 esc!

	if (argp@ ~~)
		return
	end

	while (argp@ gb)
		if (l@ 255 >=)
			1 p -=

			while (p@ gb)
				0 p@ sb
				1 p -=
			end

			return
		end

		if (esc@)
			0 esc!
			argp@ gb p@ sb
			1 p +=
			1 l +=
		end elseif (argp@ gb ' ' ==)
			0 p@ sb
			1 p +=
			1 l +=
		end elseif (argp@ gb '\\' ==)
			1 esc!
		end else
			argp@ gb p@ sb
			1 p +=
			1 l +=
		end

		1 argp +=
	end

	0 p@ sb
end

struct LdrPCVolume
    4 Block
    4 MaxAddressableBlock
    2 TrackSizeI
    2 NumHeadsI
    1 DriveB
endstruct

buffer LdrPCBootVolume LdrPCVolume_SIZEOF

fn LdrPCMain { block drive cmdline -- }
	// clear BSS section

	pointerof _bss
	pointerof _bss_end pointerof _bss -
	0 memset

    // store arguments

    block@ LdrPCBootVolume LdrPCVolume_Block + !
    drive@ LdrPCBootVolume LdrPCVolume_DriveB + sb

	// convert arguments to HAL-preferred format

    cmdline@ LdrPCMaybeEditCommandLine
	cmdline@ ArgsInit

    // get HAL name

    "HALPC.dll" LdrPlatformHALName!

    // call generic bootloader entrypoint

    LdrMain LdrExit
end

extern LdrPCHalt { -- }

fn LdrPlatformExit { ret -- }
    ret@ "\nBootloader exited with code %i\nPress Ctrl+Alt+Del to restart.\n" Printf
    LdrPCHalt
end

fn LdrPlatformBootDriversLoadAll { -- }
	// load all the PC drivers

	auto ok
	0 // flags
	"PC.sys" // name
	LdrBootDriverLoad ok! drop

	if (ok@)
		ok@ "LdrBootDrivers: failed to load PC.sys (%i)\n" LdrCrash
	end

	pointerof LdrBootDriverCallback // callback
	"/mintia/PCHardwareConfig.txt" // path
	LdrBootDevice // device
	LdrResourceFileParse ok!

	if (ok@ ok@ LDRSTATUS_NOT_FOUND ~= &&)
		ok@ "LdrBootDriversLoadAll: couldn't open /mintia/PCHardwareConfig.txt (%i)\n" Printf
		return
	end
end

extern LdrPCCallInterrupt { vec regs -- }

struct LdrPCRegs
    4 edi
    4 esi
    4 ebp
    4 padding
    4 ebx
    4 edx
    4 ecx
    4 eax
    2 dsI
    2 esI
    2 fsI
    2 gsI
    4 eflags
endstruct

fn private LdrPCMaybeEditCommandLine { cmdline -- }
    auto length
    cmdline@ strlen length!

    while (length 0 >)
        if (cmdline@ length@ 1 - + gb '\n' ~=)
            break
        end

        1 length -=
        0 cmdline@ length@ + sb
    end

    auto i
    while (i@ length@ <)
        auto c
        cmdline@ i@ + gb c!

        if (c@ '\n' == c@ '\r' == || c@ '\t' == ||)
            ' ' cmdline@ i@ + sb
        end elseif (c@ 0x20 < c@ 0x7e > ||)
            '?' cmdline@ i@ + sb
        end

        1 i +=
    end

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    // check if user is holding a modifier key
    regs@ LdrPCRegs_SIZEOF 0 memset
    0x200 regs@ LdrPCRegs_eax + !
    0x16 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eax + @ 15 & ~~)
        return
    end

    // get screen width
    auto width
    regs@ LdrPCRegs_SIZEOF 0 memset
    0xf00 regs@ LdrPCRegs_eax + !
    0x10 regs@ LdrPCCallInterrupt
    regs@ LdrPCRegs_eax + @ 8 >> 0xff & width!

    cmdline@ "\nEnter command line: %s" Printf

    while (1)
        auto scancode
        auto ascii
        regs@ LdrPCRegs_SIZEOF 0 memset
        0x16 regs@ LdrPCCallInterrupt
        regs@ LdrPCRegs_eax + @ 0xff & ascii!
        regs@ LdrPCRegs_eax + @ 8 >> 0xff & scancode!

        if (ascii@ 0x20 >= ascii@ 0x7e <= &&)
            if (length@ 255 <)
                ascii@ cmdline@ length@ + sb
                1 length +=
                0 cmdline@ length@ + sb

                ascii@ Putc
            end

            continue
        end

        if (ascii@ '\r' ==)
            '\n' Putc
            break
        end

        if (ascii@ '\b' ==)
            if (length@ 0 ==)
                continue
            end

            1 length -=
            0 cmdline@ length@ + sb

            auto x
            auto y
            regs@ LdrPCRegs_SIZEOF 0 memset
            0x300 regs@ LdrPCRegs_eax + !
            0x10 regs@ LdrPCCallInterrupt
            regs@ LdrPCRegs_edx + @ 0xff & x!
            regs@ LdrPCRegs_edx + @ 8 >> 0xff & y!

            if (x@ 0 ~=)
                1 x -=
            end elseif (y@ 0 ~=)
                1 y -=
                width@ 1 - x!
            end else
                continue
            end

            regs@ LdrPCRegs_SIZEOF 0 memset
            0x200 regs@ LdrPCRegs_eax + !
            x@ y@ 8 << | regs@ LdrPCRegs_edx + !
            0x10 regs@ LdrPCCallInterrupt

            regs@ LdrPCRegs_SIZEOF 0 memset
            0x920 regs@ LdrPCRegs_eax + !
            7 regs@ LdrPCRegs_ebx + !
            1 regs@ LdrPCRegs_ecx + !
            0x10 regs@ LdrPCCallInterrupt
        end
    end
end

extern LdrI386StartSystem { -- }

fn LdrPlatformStartSystem { -- }
    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    if (LdrPCVideoMode@ -1 ~=)
        regs@ LdrPCRegs_SIZEOF 0 memset
        0x4f02 regs@ LdrPCRegs_eax + !
        LdrPCVideoMode@ regs@ LdrPCRegs_ebx + !
        0x10 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eax + gi 0x4f ~=)
            "LdrPlatformStartSystem: failed to set video mode\n"
            -1 LdrPCVideoMode!
        end
    end

    LdrI386StartSystem

    if (LdrPCVideoMode@ -1 ~=)
        regs@ LdrPCRegs_SIZEOF 0 memset
        0x03 regs@ LdrPCRegs_eax + ! // 80x25 text mode
        0x10 regs@ LdrPCCallInterrupt
    end
end

const LDRPCIOBUFFERSIZE 0x10000

buffer LdrPCIOBuffer LDRPCIOBUFFERSIZE

fn (LdrReadFunction) private LdrPCReadCHS { length buf offset file -- bytesread ok }
    auto blocksize
    file@ LdrFile_BlockSize + @ blocksize!

    if (offset@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ ~~)
        0 ok!
        0 bytesread!
        return
    end

    auto volume
    file@ LdrFile_DriverContext + @ volume!

    auto block
    offset@ blocksize@ / volume@ LdrPCVolume_Block + @ + block!

    auto count
    length@ blocksize@ / count!

    if (block@ count@ + 1 - volume@ LdrPCVolume_MaxAddressableBlock + @ >)
        LDRSTATUS_IO_ERROR ok!
        return
    end

    0 bytesread!

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    auto tracksize
    auto numheads
    auto drive
    volume@ LdrPCVolume_TrackSizeI + gi tracksize!
    volume@ LdrPCVolume_NumHeadsI + gi numheads!
    volume@ LdrPCVolume_DriveB + gb drive!

    auto sector
    auto head
    auto cylinder
    block@ tracksize@ % sector!
    block@ tracksize@ / numheads@ % head!
    block@ tracksize@ / numheads@ / cylinder!

    while (count@)
        // determine number of blocks to read. a single operation cannot cross a 64K boundary, or a track boundary.

        auto segmentcount
        0x10000 buf@ 0xffff & - blocksize@ / segmentcount!

        auto realbuf
        buf@ realbuf!

        if (buf@ 0x100000 >= segmentcount@ 0 == |)
            LdrPCIOBuffer realbuf!
            0x10000 realbuf@ 0xffff & - blocksize@ / segmentcount!

            if (segmentcount@ 0 ==)
                realbuf@ 0xffff + 0xffff ~ & realbuf!
                0x10000 blocksize@ / segmentcount!
            end

            if (segmentcount@ LdrPCIOBuffer LDRPCIOBUFFERSIZE + realbuf@ - blocksize@ / >)
                LdrPCIOBuffer LDRPCIOBUFFERSIZE + realbuf@ - blocksize@ / segmentcount!
            end
        end

        auto currentcount
        tracksize@ sector@ - currentcount!

        if (currentcount@ segmentcount@ >)
            segmentcount@ currentcount!
        end

        if (currentcount@ count@ >)
            count@ currentcount!
        end

        auto i
        5 i!

        // perform the read

        while (i@)
            regs@ LdrPCRegs_SIZEOF 0 memset
            0x200 count@ | regs@ LdrPCRegs_eax + !
            sector@ 1 + cylinder@ 0xff & 8 << | cylinder@ 0x300 & 2 >> | regs@ LdrPCRegs_ecx + !
            head@ 8 << drive@ | regs@ LdrPCRegs_edx + !
            realbuf@ 4 >> regs@ LdrPCRegs_esI + si
            realbuf@ 15 & regs@ LdrPCRegs_ebx + !
            0x13 regs@ LdrPCCallInterrupt

            if (regs@ LdrPCRegs_eflags + @ 1 & ~~)
                break
            end

            // reset drive and try again
            regs@ LdrPCRegs_SIZEOF 0 memset
            drive@ regs@ LdrPCRegs_edx + !
            0x13 regs@ LdrPCCallInterrupt

            1 i -=
        end

        if (i@ ~~)
            LDRSTATUS_IO_ERROR ok!
            return
        end

        if (realbuf@ buf@ ~=)
            buf@ realbuf@ currentcount@ blocksize@ * memcpy
        end

        // advance

        currentcount@ blocksize@ * bytesread +=
        currentcount@ count -=

        if (count@ ~~)
            break
        end

        currentcount@ blocksize@ * buf +=

        currentcount@ sector +=

        if (sector@ tracksize@ ==)
            0 sector!
            1 head +=

            if (head@ numheads@ ==)
                0 head!
                1 cylinder +=
            end
        end
    end

    0 ok!
    return
end

struct LdrPCDiskPacket
    2 PacketSizeI
    2 BlockCountI
    2 OffsetI
    2 SegmentI
    8 Block
endstruct

fn (LdrReadFunction) private LdrPCReadLBA { length buf offset file -- bytesread ok }
    auto blocksize
    file@ LdrFile_BlockSize + @ blocksize!

    if (offset@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ ~~)
        0 ok!
        0 bytesread!
        return
    end

    auto volume
    file@ LdrFile_DriverContext + @ volume!

    auto block
    offset@ blocksize@ / volume@ LdrPCVolume_Block + @ + block!

    auto count
    length@ blocksize@ / count!

    0 bytesread!

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    auto packet
    LdrPCDiskPacket_SIZEOF alloc packet!

    auto drive
    volume@ LdrPCVolume_DriveB + gb drive!

    while (count@)
        // determine number of blocks to read. a single operation can read at most 127 blocks.

        auto currentcount
        count@ currentcount!

        auto realbuf
        buf@ realbuf!

        if (buf@ 0x100000 blocksize@ - >)
            LdrPCIOBuffer realbuf!

            if (currentcount@ LDRPCIOBUFFERSIZE blocksize@ / >)
                LDRPCIOBUFFERSIZE blocksize@ / currentcount!
            end
        end else
            auto maxlowmem
            0x100000 buf@ - blocksize@ / maxlowmem!

            if (currentcount@ maxlowmem@ >)
                maxlowmem@ currentcount!
            end
        end

        if (currentcount@ 127 >)
            127 currentcount!
        end

        // perform the read

        LdrPCDiskPacket_SIZEOF packet@ LdrPCDiskPacket_PacketSizeI + si
        currentcount@ packet@ LdrPCDiskPacket_BlockCountI + si
        realbuf@ 15 & packet@ LdrPCDiskPacket_OffsetI + si
        realbuf@ 4 >> packet@ LdrPCDiskPacket_SegmentI + si
        block@ packet@ LdrPCDiskPacket_Block + !
        0 packet@ LdrPCDiskPacket_Block 4 + + !

        regs@ LdrPCRegs_SIZEOF 0 memset
        0x4200 regs@ LdrPCRegs_eax + !
        drive@ regs@ LdrPCRegs_edx + !
        packet@ regs@ LdrPCRegs_esi + !
        0x13 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + @ 1 &)
            LDRSTATUS_IO_ERROR ok!
            return
        end

        if (realbuf@ buf@ ~=)
            buf@ realbuf@ currentcount@ blocksize@ * memcpy
        end

        // advance

        currentcount@ blocksize@ * bytesread +=
        currentcount@ count -=

        if (count@ ~~)
            break
        end

        currentcount@ blocksize@ * buf +=

        currentcount@ block +=
    end

    0 ok!
    return
end

struct LdrPCDriveParams
    2 BufferSizeI
    2 FlagsI
    4 Cylinders
    4 Heads
    4 Sectors
    8 Blocks
    2 BlockSizeI
endstruct

fn private LdrPCInitVolume { volume device -- }
    volume@ device@ LdrFile_DriverContext + !

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    // check if int13 extensions are supported
    regs@ LdrPCRegs_SIZEOF 0 memset
    0x4100 regs@ LdrPCRegs_eax + !
    0x55aa regs@ LdrPCRegs_ebx + !
    volume@ LdrPCVolume_DriveB + gb regs@ LdrPCRegs_edx + !
    0x13 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eflags + @ 1 & ~~ regs@ LdrPCRegs_ebx + gi 0xaa55 == && regs@ LdrPCRegs_ecx + @ 1 & &&)
        auto params
        LdrPCDriveParams_SIZEOF alloc params!
        LdrPCDriveParams_SIZEOF params@ LdrPCDriveParams_BufferSizeI + si
        0 params@ LdrPCDriveParams_FlagsI + si

        regs@ LdrPCRegs_SIZEOF 0 memset
        0x4800 regs@ LdrPCRegs_eax + !
        volume@ LdrPCVolume_DriveB + gb regs@ LdrPCRegs_edx + !
        params@ regs@ LdrPCRegs_esi + !
        0x13 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + 1 &)
            "failed to initialize volume i/o\n" LdrCrash
        end

        pointerof LdrPCReadLBA device@ LdrFile_ReadFunction + !
        params@ LdrPCDriveParams_BlockSizeI + gi device@ LdrFile_BlockSize + !
    end else
        regs@ LdrPCRegs_SIZEOF 0 memset
        0x0800 regs@ LdrPCRegs_eax + !
        volume@ LdrPCVolume_DriveB + gb regs@ LdrPCRegs_edx + !
        0x13 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + 1 &)
            "failed to initialize volume i/o\n" LdrCrash
        end

        regs@ LdrPCRegs_ecx + @ 0x3f & volume@ LdrPCVolume_TrackSizeI + si
        regs@ LdrPCRegs_edx + gi 8 >> 1 + volume@ LdrPCVolume_NumHeadsI + si
        volume@ LdrPCVolume_TrackSizeI gi volume@ LdrPCVolume_NumHeadsI + gi * 1024 * 1 - volume@ LdrPCVolume_MaxAddressableBlock + !

        pointerof LdrPCReadCHS device@ LdrFile_ReadFunction + !
        512 device@ LdrFile_BlockSize + !
    end
end

fn LdrPlatformIOInit { bootdevname -- }
    if (bootdevname@)
        "LdrPlatformIOInit: arbitrary boot devices are not supported\n" LdrCrash
    end

    LdrBootDeviceName "bios" strcpy

    LdrPCBootVolume LdrBootDevice LdrPCInitVolume

    LdrPCInitVideo
end

var LdrPCVideoMode -1

struct VbeInfoBlock
    4 Signature
    2 VersionI
    2 OemStringOffI
    2 OemStringSegI
    4 Capabilities
    2 ModesOffI
    2 ModesSegI
    2 TotalMemoryI
    2 OemSoftwareRevI
    2 OemVendorNameOffI
    2 OemVendorNameSegI
    2 OemProductNameOffI
    2 OemProductNameSegI
    2 OemProductRevOffI
    2 OemProductRevSegI
    222 Reserved
    256 OemData
endstruct

struct ModeInfoBlock
    2 ModeAttributesI
    1 WinAAttributesB
    1 WinBAttributesB
    2 WinGranularityI
    2 WinSizeI
    2 WinASegmentI
    2 WinBSegmentI
    2 WinFuncOffI
    2 WinFuncSegI
    2 BytesPerScanLineI
    2 XResolutionI
    2 YResolutionI
    1 XCharSizeB
    1 YCharSizeB
    1 NumberOfPlanesB
    1 BitsPerPixelB
    1 NumberOfBanksB
    1 MemoryModelB
    1 BankSizeB
    1 NumberOfImagePagesB
    1 ReservedB
    1 RedMaskSizeB
    1 RedFieldPositionB
    1 GreenMaskSizeB
    1 GreenFieldPositionB
    1 BlueMaskSizeB
    1 BlueFieldPositionB
    1 RsvdMaskSizeB
    1 RsvdFieldPositionB
    1 DirectColorModeInfoB
    4 PhysBasePtr
    4 Reserved
    2 ReservedI
    2 LinBytesPerScanLineI
    1 BnkNumberOfImagePagesB
    1 LinNumberOfImagePagesB
    1 LinRedMaskSizeB
    1 LinRedFieldPositionB
    1 LinGreenMaskSizeB
    1 LinGreenFieldPositionB
    1 LinBlueMaskSizeB
    1 LinBlueFieldPositionB
    1 LinRsvdMaskSizeB
    1 LinRsvdFieldPositionB
    4 MaxPixelClock
    190 Reserved0
endstruct

const VBE3 0x300

const VBE_MODE_SUPPORTED 0x01
const VBE_MODE_GEOMETRY 0x02
const VBE_MODE_COLOR 0x08
const VBE_MODE_GRAPHICS 0x10
const VBE_MODE_LINEAR_FB 0x80

const VBE_MODE_WANTED (VBE_MODE_SUPPORTED VBE_MODE_GEOMETRY | VBE_MODE_COLOR | VBE_MODE_GRAPHICS | VBE_MODE_LINEAR_FB |)

const VBE_MODEL_DIRECT 6

fn private LdrPCCompareModes { width height curwidth curheight wantedwidth wantedheight edidwidth edidheight -- res }
    if (width@ curwidth@ == height@ curheight@ == &&)
        0 res!
        return
    end

    -1 res!

    if (curwidth@ wantedwidth@ ==)
        if (width@ wantedwidth@ ~=)
            return
        end
    end elseif (width@ wantedwidth@ ==)
        1 res!
        return
    end

    if (curheight@ wantedheight@ ==)
        if (height@ wantedheight@ ~=)
            return
        end
    end elseif (height@ wantedheight@ ==)
        1 res!
        return
    end

    if (curwidth@ edidwidth@ ==)
        if (width@ edidwidth@ ~=)
            return
        end
    end elseif (width@ edidwidth@ ==)
        1 res!
        return
    end

    if (curheight@ edidheight@ ==)
        if (height@ edidheight@ ~=)
            return
        end
    end elseif (height@ edidheight@ ==)
        1 res!
        return
    end

    if (width@ height@ * curwidth@ curheight@ * <)
        return
    end elseif (width@ height@ * curwidth@ curheight@ * >)
        1 res!
        return
    end

    if (width@ curwidth@ >)
        1 res!
    end
end

fn private LdrPCInitVideo { -- }
    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    auto vbeinfo
    VbeInfoBlock_SIZEOF alloc vbeinfo!
    '2EBV' vbeinfo@ VbeInfoBlock_Signature + !

    auto modeinfo
    ModeInfoBlock_SIZEOF alloc modeinfo!

    // detect vbe
    regs@ LdrPCRegs_SIZEOF 0 memset
    0x4f00 regs@ LdrPCRegs_eax + !
    vbeinfo@ regs@ LdrPCRegs_edi + !
    0x10 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eax + gi 0x4f ~=)
        "LdrPCInitVideo: VBE not supported, no video will be available\n" Printf
        return
    end

    auto wantedwidth
    auto wantedheight
    "WIDTH" LdrArgsValue wantedwidth!
    "HEIGHT" LdrArgsValue wantedheight!

    if (wantedwidth@)
        wantedwidth@ atoi wantedwidth!
    end

    if (wantedheight@)
        wantedheight@ atoi wantedheight!
    end

    auto edidwidth
    auto edidheight
    0 edidwidth!
    0 edidheight!

    // check if edid is supported
    regs@ LdrPCRegs_SIZEOF 0 memset
    0x4f15 regs@ LdrPCRegs_eax + !
    0x10 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eax + gi 0x4f ==)
        auto edidbuf
        128 alloc edidbuf!

        // get edid info
        regs@ LdrPCRegs_SIZEOF 0 memset
        0x4f15 regs@ LdrPCRegs_eax + !
        1 regs@ LdrPCRegs_ebx + !
        edidbuf@ regs@ LdrPCRegs_edi + !
        0x10 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eax + gi 0x4f ==)
            if (edidbuf@@ 0xffffff00 == edidbuf@ 4 + @ 0xffffff == && edidbuf@ 0x36 + gb edidbuf@ 0x37 + gb || &&)
                edidbuf@ 0x38 + gb edidbuf@ 0x3a + gb 0xf0 & 4 << | edidwidth!
                edidbuf@ 0x3b + gb edidbuf@ 0x3d + gb 0xf0 & 4 << | edidheight!
            end
        end
    end

    auto modes
    vbeinfo@ VbeInfoBlock_ModesSegI + gi 4 << vbeinfo@ VbeInfoBlock_ModesOffI + gi + modes!

    auto curwidth
    -1 curwidth!

    auto curheight
    -1 curheight!

    auto curpitch
    -1 curpitch!

    auto curaddr
    -1 curaddr!

    auto curmode
    -1 curmode!

    while (1)
        auto mode
        modes@ gi mode!
        2 modes +=

        if (mode@ 0xffff ==)
            break
        end

        // get mode info
        regs@ LdrPCRegs_SIZEOF 0 memset
        0x4f01 regs@ LdrPCRegs_eax + !
        mode@ regs@ LdrPCRegs_ecx + !
        modeinfo@ regs@ LdrPCRegs_edi + !
        0x10 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eax + gi 0x4f ~=)
            continue
        end

        if (modeinfo@ ModeInfoBlock_ModeAttributesI + gi VBE_MODE_WANTED & VBE_MODE_WANTED ~=)
            continue
        end

        if (modeinfo@ ModeInfoBlock_BitsPerPixelB + gb 32 ~=)
            continue
        end

        if (modeinfo@ ModeInfoBlock_MemoryModelB + gb VBE_MODEL_DIRECT ~=)
            continue
        end

        auto redfieldpos
        auto redmasksize
        auto greenfieldpos
        auto greenmasksize
        auto bluefieldpos
        auto bluemasksize
        auto pitch

        if (vbeinfo@ VbeInfoBlock_VersionI + gi VBE3 <)
            modeinfo@ ModeInfoBlock_RedFieldPositionB + gb redfieldpos!
            modeinfo@ ModeInfoBlock_RedMaskSizeB + gb redmasksize!
            modeinfo@ ModeInfoBlock_GreenFieldPositionB + gb greenfieldpos!
            modeinfo@ ModeInfoBlock_GreenMaskSizeB + gb greenmasksize!
            modeinfo@ ModeInfoBlock_BlueFieldPositionB + gb bluefieldpos!
            modeinfo@ ModeInfoBlock_BlueMaskSizeB + gb bluemasksize!
            modeinfo@ ModeInfoBlock_BytesPerScanLineI + gi pitch!
        end else
            modeinfo@ ModeInfoBlock_LinRedFieldPositionB + gb redfieldpos!
            modeinfo@ ModeInfoBlock_LinRedMaskSizeB + gb redmasksize!
            modeinfo@ ModeInfoBlock_LinGreenFieldPositionB + gb greenfieldpos!
            modeinfo@ ModeInfoBlock_LinGreenMaskSizeB + gb greenmasksize!
            modeinfo@ ModeInfoBlock_LinBlueFieldPositionB + gb bluefieldpos!
            modeinfo@ ModeInfoBlock_LinBlueMaskSizeB + gb bluemasksize!
            modeinfo@ ModeInfoBlock_LinBytesPerScanLineI + gi pitch!
        end

        if (redfieldpos@ 16 ~= redmasksize@ 8 ~= ||)
            continue
        end

        if (greenfieldpos@ 8 ~= greenmasksize@ 8 ~= ||)
            continue
        end

        if (bluefieldpos@ 0 ~= bluemasksize@ 8 ~= ||)
            continue
        end

        auto width
        auto height
        modeinfo@ ModeInfoBlock_XResolutionI + gi width!
        modeinfo@ ModeInfoBlock_YResolutionI + gi height!

        if (curmode@ -1 ~=)
            auto cmpres
            width@ height@ curwidth@ curheight@ wantedwidth@ wantedheight@ edidwidth@ edidheight@ LdrPCCompareModes cmpres!

            if (cmpres@ 0 s<=)
                continue
            end
        end

        width@ curwidth!
        height@ curheight!
        pitch@ curpitch!
        modeinfo@ ModeInfoBlock_PhysBasePtr + @ curaddr!
        mode@ curmode!
    end

    if (curmode@ -1 ==)
        "LdrPCInitVideo: no video modes available\n" Printf
        return
    end

    auto ok
    auto vaddr
	height@ pitch@ * PAGEOFFSETMASK + PAGESHIFT >> // pages
	curaddr@ // phyaddr
	LDRMEM_WRITECOMBINE // noncached
	LdrMemoryMapIORegion ok! vaddr!

    if (ok@)
        ok@ "LdrPCInitVideo: failed to map framebuffer (%i)\n" Printf
        return
    end

    curwidth@             LdrInfoBlock LdrInfo_HALConsoleFBWidth + !
    curheight@            LdrInfoBlock LdrInfo_HALConsoleFBHeight + !
    OSBOOTFBFORMAT_RGBA32 LdrInfoBlock LdrInfo_HALConsoleFBFormat + !
    vaddr@                LdrInfoBlock LdrInfo_HALConsoleFBAddr + !
    curpitch@             LdrInfoBlock LdrInfo_HALConsoleFBPitch + !

    curmode@ 0x4000 | LdrPCVideoMode!

    curaddr@ vaddr@ curheight@ curwidth@ "LdrPCInitVideo: using %dx%d framebuffer @ 0x%x (0x%x)\n" Printf
end

const LDR_PC_MEMORY_FREE 1

fnptr LdrPCMemoryFunc { head tail type context -- }

struct LdrPCE820
    8 Start
    8 Size
    4 Type
endstruct

fn LdrPCIterateMemoryMap { func context -- }
    auto key
    0 key!

    auto count
    0 count!

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    while (1)
        auto buffer
        LdrPCE820_SIZEOF alloc buffer!

        regs@ LdrPCRegs_SIZEOF 0 memset
        0xe820 regs@ LdrPCRegs_eax + !
        'SMAP' regs@ LdrPCRegs_edx + !
        key@ regs@ LdrPCRegs_ebx + !
        LdrPCE820_SIZEOF regs@ LdrPCRegs_ecx + !
        buffer@ regs@ LdrPCRegs_edi + !
        0x15 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + @ 1 &)
            break
        end

        regs@ LdrPCRegs_ebx + @ key!

        auto size
        buffer@ LdrPCE820_Size + @ size!

        if (buffer@ LdrPCE820_Size 4 + + @)
            -1 size!
        end

        if (size@ ~~ buffer@ LdrPCE820_Start 4 + + @)
            if (key@ ~~)
                break
            end

            continue
        end

        auto head
        buffer@ LdrPCE820_Start + @ head!

        head@ 1 - size +=
        if (size@ head@ <)
            -1 size!
        end

        if (head@ 0x100000 <)
            if (size@ 0x100000 <)
                if (key@ ~~)
                    break
                end

                continue
            end

            0x100000 head!
        end

        head@ size@ buffer@ LdrPCE820_Type + @ context@ func@ LdrPCMemoryFunc
        1 count +=

        if (key@ ~~)
            break
        end
    end

    if (count@)
        return
    end

    auto low
    auto high

    regs@ LdrPCRegs_SIZEOF 0 memset
    0xe801 regs@ LdrPCRegs_eax + !
    0x15 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eflags + @ 1 & ~~)
        regs@ LdrPCRegs_ecx + gi low!

        if (low@)
            regs@ LdrPCRegs_edx + gi high!
        end else
            regs@ LdrPCRegs_eax + gi low!
            regs@ LdrPCRegs_ebx + gi high!
        end

        1024 low *=
        0x10000 high *=

        if (low@)
            0xfffff low +=

            if (low@ 0xffffff > high@ &&)
                0xffffff low!
            end

            if (low@ 0xffffff ==)
                high@ low +=

                if (low@ high@ <)
                    -1 low!
                end

                0 high!
            end

            0x100000 low@ LDR_PC_MEMORY_FREE context@ func@ LdrPCMemoryFunc
        end

        if (high@)
            0xffffff high +=

            if (high@ 0xffffff <)
                -1 high!
            end

            0x1000000 high@ LDR_PC_MEMORY_FREE context@ func@ LdrPCMemoryFunc
        end

        return
    end

    regs@ LdrPCRegs_SIZEOF 0 memset
    0x8800 regs@ LdrPCRegs_eax + !
    0x15 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eflags + @ 1 & ~~)
        regs@ LdrPCRegs_eax + gi low!
        1024 low *=

        if (low@)
            0xfffff low +=

            LDR_PC_MEMORY_FREE low@ 0x100000 context@ func@ LdrPCMemoryFunc
        end
    end
end

// during build, LdrMemoryDescriptor fields are reused with different meanings as follows:
//  StartPFN: head
//  Pages: tail
//  OriginalExtent: prev

fn (LdrPCMemoryFunc) private LdrPCAddFreeRegion { head tail type context -- }
    if (type@ LDR_PC_MEMORY_FREE ~=)
        return
    end

    auto ldrtype
    OSLOADERMEM_FREE ldrtype!

    // mark physical ranges beyond KERNELSPACE as reclaiamble instead of free because the loader can't access those

    if (tail@ KERNELSPACE >=)
        if (head@ KERNELSPACE <)
            head@ KERNELSPACE 1 - type@ context@ LdrPCAddFreeRegion
            KERNELSPACE head!
        end

        OSLOADERMEM_RECLAIMABLE ldrtype!
    end

    // find insertion location (starting at the tail so that the common case of already-sorted is fast)

    auto prev
    context@ 4 + @ prev!

    auto next
    0 next!

    while (prev@)
        if (prev@ LdrMemoryDescriptor_StartPFN + @ head@ <)
            break
        end

        prev@ next!
        prev@ LdrMemoryDescriptor_OriginalExtent + @ prev!
    end

    // remove overlapping and neighboring followers

    while (next@)
        if (tail@ -1 < tail@ + 1 next@ LdrMemoryDescriptor_StartPFN + @ < &&)
            break
        end

        if (next@ LdrMemoryDescriptor_Pages + @ tail@ >)
            next@ LdrMemoryDescriptor_Pages + @ tail!
        end

        next@ LdrMemoryDescriptor_Next + @ next!

        if (prev@)
            next@ prev@ LdrMemoryDescriptor_Next + !
        end else
            next@ context@!
        end

        if (next@)
            prev@ next@ LdrMemoryDescriptor_OriginalExtent + !
        end else
            prev@ context@ 4 + !
        end
    end

    // merge with prev if possible

    if (prev@)
        if (prev@ LdrMemoryDescriptor_Pages + @ tail@ >=)
            return
        end

        if (prev@ LdrMemoryDescriptor_Type + @ ldrtype @ ==)
            tail@ prev@ LdrMemoryDescriptor_Pages + !
            return
        end
    end

    // create a new descriptor

	auto ok
	auto ldrdesc
	LdrMemoryDescriptor_SIZEOF // size
	LdrMemoryAllocate ok! ldrdesc!

	if (ok@)
		ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	end

    next@ ldrdesc@ LdrMemoryDescriptor_Next + !
    ldrtype@ ldrdesc@ LdrMemoryDescriptor_Type + !
    head@ ldrdesc@ LdrMemoryDescriptor_StartPFN + !
    tail@ ldrdesc@ LdrMemoryDescriptor_Pages + !
    prev@ ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !
    1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !

    // insert it

    if (prev@)
        ldrdesc@ prev@ LdrMemoryDescriptor_Next + !
    end else
        ldrdesc@ context@!
    end

    if (next@)
        ldrdesc@ next@ LdrMemoryDescriptor_OriginalExtent + !
    end else
        ldrdesc@ context@ 4 + !
    end
end

fn (LdrPCMemoryFunc) private LdrPCRemoveReservedRegion { head tail type context -- }
    if (type@ LDR_PC_MEMORY_FREE ==)
        return
    end

    // find location (starting at the tail so that the common case of already-sorted is fast)

    auto prev
    context@ 4 + @ prev!

    auto next
    0 next!

    while (prev@)
        if (prev@ LdrMemoryDescriptor_StartPFN + @ head@ <)
            break
        end

        prev@ next!
        prev@ LdrMemoryDescriptor_OriginalExtent + @ prev!
    end

    // remove overlapping parts of prev

    if (prev@)
        if (prev@ LdrMemoryDescriptor_Pages + @ tail@ >)
            // create a new descriptor

	        auto ok
	        auto ldrdesc
	        LdrMemoryDescriptor_SIZEOF // size
	        LdrMemoryAllocate ok! ldrdesc!

	        if (ok@)
	        	ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	        end

            next@ ldrdesc@ LdrMemoryDescriptor_Next + !
            prev@ LdrMemoryDescriptor_Type + @ ldrdesc@ LdrMemoryDescriptor_Type + !
            tail@ 1 + ldrdesc@ LdrMemoryDescriptor_StartPFN + !
            prev@ LdrMemoryDescriptor_Pages + @ ldrdesc@ LdrMemoryDescriptor_Pages + !
            prev@ ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !
            1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !

            // insert it

            ldrdesc@ prev@ LdrMemoryDescriptor_Next + !

            if (next@)
                ldrdesc@ next@ LdrMemoryDescriptor_OriginalExtent + !
            end else
                ldrdesc@ context@ 4 + !
            end

            ldrdesc@ next!
        end

        if (prev@ LdrMemoryDescriptor_Pages + @ head@ >=)
            head@ 1 - prev@ LdrMemoryDescriptor_Pages + !
        end
    end

    // remove overlapping parts of next until it doesn't overlap

    while (next@)
        if (tail@ next@ LdrMemoryDescriptor_StartPFN + @ <)
            break
        end

        if (tail@ next@ LdrMemoryDescriptor_Pages + @ <)
            tail@ 1 + next@ LdrMemoryDescriptor_StartPFN + !
            break
        end

        next@ LdrMemoryDescriptor_Next + @ next!

        if (prev@)
            next@ prev@ LdrMemoryDescriptor_Next + !
        end else
            next@ context@!
        end

        if (next@)
            prev@ next@ LdrMemoryDescriptor_OriginalExtent + !
        end else
            prev@ context@ 4 + !
        end
    end
end

const LDRINITIALHEAPSIZE 262144

fn private LdrPCBuildDescriptors { -- }
	// initialize the heap as an 256KB chunk at the end of low memory.

    auto regs
    LdrPCRegs_SIZEOF alloc regs!
    regs@ LdrPCRegs_SIZEOF 0 memset
    0x12 regs@ LdrPCCallInterrupt

    regs@ LdrPCRegs_eax + gi 10 << PAGENUMBERMASK & LdrHeapTop!
    LdrHeapTop@ LDRINITIALHEAPSIZE - LdrHeapPointer!

    if (LdrHeapPointer@ pointerof _bss_end <)
        "not enough memory for heap\n" LdrCrash
    end

    // build memory descriptors for low memory

    auto rtop
    pointerof _bss_end PAGEOFFSETMASK + PAGENUMBERMASK & rtop!

    auto hbottom
    LdrHeapPointer@ PAGENUMBERMASK & hbottom!

    auto htop
    LdrHeapTop@ PAGENUMBERMASK & htop!

    if (rtop@ hbottom@ >=)
        htop@ rtop!
        htop@ hbottom!
    end else
        hbottom@ LdrHeapPointer!
    end

    htop@ LdrMemoryTotalRAM +=

	auto ok
	auto ldrdesc

    // allocate the descriptor for the reclaimable memory range.

	LdrMemoryDescriptor_SIZEOF // size
	LdrMemoryAllocate ok! ldrdesc!

	if (ok@)
		ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	end

	0 ldrdesc@ LdrMemoryDescriptor_Next + !
	OSLOADERMEM_RECLAIMABLE ldrdesc@ LdrMemoryDescriptor_Type + !
	0 ldrdesc@ LdrMemoryDescriptor_StartPFN + !
	rtop@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_Pages + !

	1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !
	rtop@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

	ldrdesc@ LdrMemoryDescriptorListHead!
	ldrdesc@ LdrMemoryDescriptorListTail!

    // allocate the descriptor for the first free range.

	if (rtop@ hbottom@ <)
        LdrMemoryDescriptor_SIZEOF // size
	    LdrMemoryAllocate ok! ldrdesc!

	    if (ok@)
	    	ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	    end

	    0 ldrdesc@ LdrMemoryDescriptor_Next + !
	    OSLOADERMEM_FREE ldrdesc@ LdrMemoryDescriptor_Type + !
	    rtop@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_StartPFN + !
	    hbottom@ rtop@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_Pages + !

	    1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !
	    hbottom@ rtop@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

	    ldrdesc@ LdrMemoryDescriptorListTail@ LdrMemoryDescriptor_Next + !
	    ldrdesc@ LdrMemoryDescriptorListTail!
    end

    // allocate the descriptor for the first heap range.

    if (hbottom@ htop@ <)
	    LdrMemoryDescriptor_SIZEOF // size
	    LdrMemoryAllocate ok! ldrdesc!

	    if (ok@)
	    	ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	    end

	    0 ldrdesc@ LdrMemoryDescriptor_Next + !
	    OSLOADERMEM_RECLAIMABLE ldrdesc@ LdrMemoryDescriptor_Type + !
	    hbottom@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_StartPFN + !
	    htop@ hbottom@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_Pages + !

	    1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !
	    htop@ hbottom@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

	    ldrdesc@ LdrMemoryDescriptorListTail@ LdrMemoryDescriptor_Next + !
	    ldrdesc@ LdrMemoryDescriptorListTail!
    end

    // allocate the descriptor for the BIOS area (this causes the area to be mapped)

	LdrMemoryDescriptor_SIZEOF // size
	LdrMemoryAllocate ok! ldrdesc!

	if (ok@)
		ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	end

	0 ldrdesc@ LdrMemoryDescriptor_Next + !
	OSLOADERMEM_USED ldrdesc@ LdrMemoryDescriptor_Type + !
	htop@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_StartPFN + !
	0x100000 htop@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_Pages + !

	1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !
	0x100000 htop@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

	ldrdesc@ LdrMemoryDescriptorListTail@ LdrMemoryDescriptor_Next + !
	ldrdesc@ LdrMemoryDescriptorListTail!

    // build list of free regions in high memory

    auto highlist
    8 alloc highlist!
    0 highlist@!
    0 highlist@ 4 + !
    pointerof LdrPCAddFreeRegion highlist@ LdrPCIterateMemoryMap

    // remove reserved regions from list

    pointerof LdrPCRemoveReservedRegion highlist@ LdrPCIterateMemoryMap

    // convert temporary format to proper one

    highlist@@ ldrdesc!

    while (ldrdesc@)
        ldrdesc@ LdrMemoryDescriptor_Next + @ highlist!

        ldrdesc@ LdrMemoryDescriptor_StartPFN + @ hbottom!
        ldrdesc@ LdrMemoryDescriptor_Pages + @ htop!

        hbottom@ PAGEOFFSETMASK + PAGENUMBERMASK & ok!
        htop@ PAGEOFFSETMASK - PAGEOFFSETMASK | rtop!

        if (hbottom@ ok@ <= htop@ rtop@ >= && ok@ rtop@ <=)
            rtop@ ok@ - 1 + LdrMemoryTotalRAM +=

            0 ldrdesc@ LdrMemoryDescriptor_Next + !
            ok@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_StartPFN + !
            rtop@ ok@ - PAGESHIFT >> 1 + ldrdesc@ LdrMemoryDescriptor_Pages + !
            rtop@ ok@ - PAGESHIFT >> 1 + ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

            ldrdesc@ LdrMemoryDescriptorListTail@ LdrMemoryDescriptor_Next + !
            ldrdesc@ LdrMemoryDescriptorListTail!
        end

        highlist@ ldrdesc!
    end
end

extern LdrI386MapInit { -- }

fn LdrPlatformMemoryInit { -- }
    LdrPCBuildDescriptors

    // allocate a kernel space bitmap

    auto desc
    auto ok
    MANAGEDKERNELSPACESIZE PAGESHIFT >> 7 + 3 >> PAGEOFFSETMASK + PAGESHIFT >> // pages
    OSLOADERMEM_RECLAIMABLE // type
    LdrMemoryAllocatePhysicalRange ok! desc!

    if (ok@)
        "failed to allocate kernel space bitmap\n" LdrCrash
    end

    desc@ LdrMemoryDescriptor_StartPFN + @ PAGESHIFT << LdrKernelSpaceBitmap!

    // create IDENTITYSPACE and enable paging

    LdrI386MapInit
end

fn private LdrPCWriteChar { c -- }
    auto regs
    LdrPCRegs_SIZEOF alloc regs!
    regs@ LdrPCRegs_SIZEOF 0 memset
    0xe00 c@ | regs@ LdrPCRegs_eax + !
    0x7 regs@ LdrPCRegs_ebx + !
    0x10 regs@ LdrPCCallInterrupt
end

fn FPutc { fd c -- }
    if (c@ '\n' ==)
        '\r' LdrPCWriteChar
    end
    c@ 0xff & LdrPCWriteChar
end

fn FPuts { fd s -- }
    while (1)
        auto c
        s@ gb c!

        if (c@ ~~)
            break
        end

        fd@ c@ FPutc
        1 s +=
    end
end

fn Putc { c -- }
    1 c@ FPutc
end

fn Puts { s -- }
    1 s@ FPuts
end

fn VPrintf { argvt argcn fmt -- }
	argvt@ argcn@ fmt@ 1 VFPrintf
end

fn Malloc { size -- ptr }
    auto ok
    size@ LdrMemoryAllocate ok! ptr!

    if (ok)
        ERR ptr!
    end
end
