//
// Implements the PC-specific part of bootloader initialization.
//

#include "<df>/dragonfruit.h"

#include "../OSLoader.h"

buffer LdrArgsBuffer 256
public LdrArgsBuffer

var LdrPlatformHALName 0
public LdrPlatformHALName

fn private ArgsInit { argp -- }
	auto p
	LdrArgsBuffer p!

	auto l
	0 l!

	auto esc
	0 esc!

	if (argp@ ~~)
		return
	end

    auto inlen
    argp@ strlen inlen!

    while (inlen 0 >)
        1 inlen -=

        if (argp@ inlen@ + gb '\n' ~=)
            break
        end

        0 argp@ inlen@ + sb
    end

	while (argp@ gb)
		if (l@ 255 >=)
			1 p -=

			while (p@ gb)
				0 p@ sb
				1 p -=
			end

			return
		end

		if (esc@)
			0 esc!
			argp@ gb p@ sb
			1 p +=
			1 l +=
		end elseif (argp@ gb ' ' ==)
			0 p@ sb
			1 p +=
			1 l +=
		end elseif (argp@ gb '\\' ==)
			1 esc!
		end else
			argp@ gb p@ sb
			1 p +=
			1 l +=
		end

		1 argp +=
	end

	0 p@ sb
end

struct LdrPCVolume
    4 Block
    4 MaxAddressableBlock
    2 TrackSizeI
    2 NumHeadsI
    1 DriveB
endstruct

buffer LdrPCBootVolume LdrPCVolume_SIZEOF

fn LdrPCMain { block drive cmdline -- }
	// clear BSS section

	pointerof _bss
	pointerof _bss_end pointerof _bss -
	0 memset

    // store arguments

    block@ LdrPCBootVolume LdrPCVolume_Block + !
    drive@ LdrPCBootVolume LdrPCVolume_DriveB + sb

	// convert arguments to HAL-preferred format

	cmdline@ ArgsInit

    // get HAL name

    "HALPC.dll" LdrPlatformHALName!

    // call generic bootloader entrypoint

    LdrMain LdrExit
end

extern LdrPCHalt { -- }

fn LdrPlatformExit { ret -- }
    ret@ "bootloader exited with code %i\n" Printf
    LdrPCHalt
end

fn LdrPlatformBootDriversLoadAll { -- }
end

extern LdrI386StartSystem { -- }

fn LdrPlatformStartSystem { -- }
    LdrI386StartSystem
end

extern LdrPCCallInterrupt { vec regs -- }

struct LdrPCRegs
    4 edi
    4 esi
    4 ebp
    4 padding
    4 ebx
    4 edx
    4 ecx
    4 eax
    2 dsI
    2 esI
    2 fsI
    2 gsI
    4 eflags
endstruct

fn (LdrReadFunction) private LdrPCReadCHS { length buf offset file -- bytesread ok }
    auto blocksize
    file@ LdrFile_BlockSize + @ blocksize!

    if (buf@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (offset@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ ~~)
        0 ok!
        0 bytesread!
        return
    end

    auto volume
    file@ LdrFile_DriverContext + @ volume!

    auto block
    offset@ blocksize@ / volume@ LdrPCVolume_Block + @ + block!

    auto count
    length@ blocksize@ / count!

    if (block@ count@ + 1 - volume@ LdrPCVolume_MaxAddressableBlock + @ >)
        LDRSTATUS_IO_ERROR ok!
        return
    end

    0 bytesread!

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    auto tracksize
    auto numheads
    auto drive
    volume@ LdrPCVolume_TrackSizeI + gi tracksize!
    volume@ LdrPCVolume_NumHeadsI + gi numheads!
    volume@ LdrPCVolume_DriveB + gb drive!

    auto sector
    auto head
    auto cylinder
    block@ tracksize@ % sector!
    block@ tracksize@ / numheads@ % head!
    block@ tracksize@ / numheads@ / cylinder!

    while (count@)
        if (buf@ 0x100000 >=)
            LDRSTATUS_IO_ERROR ok!
            return
        end

        // determine number of blocks to read. a single operation cannot cross a 64K boundary, or a track boundary.

        auto segmentcount
        0x10000 buf@ 0xffff & - blocksize@ / segmentcount!

        auto currentcount
        tracksize@ sector@ - currentcount!

        if (currentcount@ segmentcount@ >)
            segmentcount@ currentcount!
        end

        if (currentcount@ count@ >)
            count@ currentcount!
        end

        auto i
        5 i!

        // perform the read

        while (i@)
            regs@ LdrPCRegs_SIZEOF 0 memset
            0x200 count@ | regs@ LdrPCRegs_eax + !
            sector@ 1 + cylinder@ 0xff & 8 << | cylinder@ 0x300 & 2 >> | regs@ LdrPCRegs_ecx + !
            head@ 8 << drive@ | regs@ LdrPCRegs_edx + !
            buf@ 4 >> regs@ LdrPCRegs_esI + si
            buf@ 15 & regs@ LdrPCRegs_ebx + !
            0x13 regs@ LdrPCCallInterrupt

            if (regs@ LdrPCRegs_eflags + @ 1 & ~~)
                break
            end

            // reset drive and try again
            regs@ LdrPCRegs_SIZEOF 0 memset
            drive@ regs@ LdrPCRegs_edx + !
            0x13 regs@ LdrPCCallInterrupt

            1 i -=
        end

        if (i@ ~~)
            LDRSTATUS_IO_ERROR ok!
            return
        end

        // advance

        currentcount@ blocksize@ * bytesread +=
        currentcount@ count -=

        if (count@ ~~)
            break
        end

        currentcount@ blocksize@ * buf +=

        currentcount@ sector +=

        if (sector@ tracksize@ ==)
            0 sector!
            1 head +=

            if (head@ numheads@ ==)
                0 head!
                1 cylinder +=
            end
        end
    end

    0 ok!
    return
end

struct LdrPCDiskPacket
    2 PacketSizeI
    2 BlockCountI
    2 OffsetI
    2 SegmentI
    8 Block
endstruct

fn (LdrReadFunction) private LdrPCReadLBA { length buf offset file -- bytesread ok }
    auto blocksize
    file@ LdrFile_BlockSize + @ blocksize!

    if (offset@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ blocksize@ %)
        LDRSTATUS_UNALIGNED ok!
        return
    end

    if (length@ ~~)
        0 ok!
        0 bytesread!
        return
    end

    auto volume
    file@ LdrFile_DriverContext + @ volume!

    auto block
    offset@ blocksize@ / volume@ LdrPCVolume_Block + @ + block!

    auto count
    length@ blocksize@ / count!

    0 bytesread!

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    auto packet
    LdrPCDiskPacket_SIZEOF alloc packet!

    auto drive
    volume@ LdrPCVolume_DriveB + gb drive!

    while (count@)
        if (buf@ 0x100000 >=)
            LDRSTATUS_IO_ERROR ok!
            return
        end

        // determine number of blocks to read. a single operation can read at most 127 blocks.

        auto currentcount
        count@ currentcount!

        if (currentcount@ 127 >)
            127 currentcount!
        end

        // perform the read

        LdrPCDiskPacket_SIZEOF packet@ LdrPCDiskPacket_PacketSizeI + si
        currentcount@ packet@ LdrPCDiskPacket_BlockCountI + si
        buf@ 15 & packet@ LdrPCDiskPacket_OffsetI + si
        buf@ 4 >> packet@ LdrPCDiskPacket_SegmentI + si
        block@ packet@ LdrPCDiskPacket_Block + !
        0 packet@ LdrPCDiskPacket_Block 4 + + !

        regs@ LdrPCRegs_SIZEOF 0 memset
        0x4200 regs@ LdrPCRegs_eax + !
        drive@ regs@ LdrPCRegs_edx + !
        packet@ regs@ LdrPCRegs_esi + !
        0x13 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + @ 1 &)
            LDRSTATUS_IO_ERROR ok!
            return
        end

        // advance

        currentcount@ blocksize@ * bytesread +=
        currentcount@ count -=

        if (count@ ~~)
            break
        end

        currentcount@ blocksize@ * buf +=

        currentcount@ block +=
    end

    0 ok!
    return
end

struct LdrPCDriveParams
    2 BufferSizeI
    2 FlagsI
    4 Cylinders
    4 Heads
    4 Sectors
    8 Blocks
    2 BlockSizeI
endstruct

fn private LdrPCInitVolume { volume device -- }
    volume@ device@ LdrFile_DriverContext + !

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    // check if int13 extensions are supported
    regs@ LdrPCRegs_SIZEOF 0 memset
    0x4100 regs@ LdrPCRegs_eax + !
    0x55aa regs@ LdrPCRegs_ebx + !
    volume@ LdrPCVolume_DriveB + gb regs@ LdrPCRegs_edx + !
    0x13 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eflags + @ 1 & ~~ regs@ LdrPCRegs_ebx + gi 0xaa55 == && regs@ LdrPCRegs_ecx + @ 1 & &&)
        auto params
        LdrPCDriveParams_SIZEOF alloc params!
        LdrPCDriveParams_SIZEOF params@ LdrPCDriveParams_BufferSizeI + si
        0 params@ LdrPCDriveParams_FlagsI + si

        regs@ LdrPCRegs_SIZEOF 0 memset
        0x4800 regs@ LdrPCRegs_eax + !
        volume@ LdrPCVolume_DriveB + gb regs@ LdrPCRegs_edx + !
        params@ regs@ LdrPCRegs_esi + !
        0x13 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + 1 &)
            "failed to initialize volume i/o\n" LdrCrash
        end

        pointerof LdrPCReadLBA device@ LdrFile_ReadFunction + !
        params@ LdrPCDriveParams_BlockSizeI + gi device@ LdrFile_BlockSize + !
    end else
        regs@ LdrPCRegs_SIZEOF 0 memset
        0x0800 regs@ LdrPCRegs_eax + !
        volume@ LdrPCVolume_DriveB + gb regs@ LdrPCRegs_edx + !
        0x13 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + 1 &)
            "failed to initialize volume i/o\n" LdrCrash
        end

        regs@ LdrPCRegs_ecx + @ 0x3f & volume@ LdrPCVolume_TrackSizeI + si
        regs@ LdrPCRegs_edx + gi 8 >> 1 + volume@ LdrPCVolume_NumHeadsI + si
        volume@ LdrPCVolume_TrackSizeI gi volume@ LdrPCVolume_NumHeadsI + gi * 1024 * 1 - volume@ LdrPCVolume_MaxAddressableBlock + !

        pointerof LdrPCReadCHS device@ LdrFile_ReadFunction + !
        512 device@ LdrFile_BlockSize + !
    end
end

fn LdrPlatformIOInit { bootdevname -- }
    if (bootdevname@)
        "LdrPlatformIOInit: arbitrary boot devices are not supported\n" LdrCrash
    end

    LdrBootDeviceName "bios" strcpy

    LdrPCBootVolume LdrBootDevice LdrPCInitVolume
end

const LDR_PC_MEMORY_FREE 1

fnptr LdrPCMemoryFunc { head tail type context -- }

struct LdrPCE820
    8 Start
    8 Size
    4 Type
endstruct

fn LdrPCIterateMemoryMap { func context -- }
    auto key
    0 key!

    auto count
    0 count!

    auto regs
    LdrPCRegs_SIZEOF alloc regs!

    while (1)
        auto buffer
        LdrPCE820_SIZEOF alloc buffer!

        regs@ LdrPCRegs_SIZEOF 0 memset
        0xe820 regs@ LdrPCRegs_eax + !
        'SMAP' regs@ LdrPCRegs_edx + !
        key@ regs@ LdrPCRegs_ebx + !
        LdrPCE820_SIZEOF regs@ LdrPCRegs_ecx + !
        buffer@ regs@ LdrPCRegs_edi + !
        0x15 regs@ LdrPCCallInterrupt

        if (regs@ LdrPCRegs_eflags + @ 1 &)
            break
        end

        regs@ LdrPCRegs_ebx + @ key!

        auto size
        buffer@ LdrPCE820_Size + @ size!

        if (buffer@ LdrPCE820_Size 4 + + @)
            -1 size!
        end

        if (size@ ~~ buffer@ LdrPCE820_Start 4 + + @)
            if (key@ ~~)
                break
            end

            continue
        end

        auto head
        buffer@ LdrPCE820_Start + @ head!

        head@ 1 - size +=
        if (size@ head@ <)
            -1 size!
        end

        if (head@ 0x100000 <)
            if (size@ 0x100000 <)
                if (key@ ~~)
                    break
                end

                continue
            end

            0x100000 head!
        end

        head@ size@ buffer@ LdrPCE820_Type + @ context@ func@ LdrPCMemoryFunc
        1 count +=

        if (key@ ~~)
            break
        end
    end

    if (count@)
        return
    end

    auto low
    auto high

    regs@ LdrPCRegs_SIZEOF 0 memset
    0xe801 regs@ LdrPCRegs_eax + !
    0x15 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eflags + @ 1 & ~~)
        regs@ LdrPCRegs_ecx + gi low!

        if (low@)
            regs@ LdrPCRegs_edx + gi high!
        end else
            regs@ LdrPCRegs_eax + gi low!
            regs@ LdrPCRegs_ebx + gi high!
        end

        1024 low *=
        0x10000 high *=

        if (low@)
            0xfffff low +=

            if (low@ 0xffffff > high@ &&)
                0xffffff low!
            end

            if (low@ 0xffffff ==)
                high@ low +=

                if (low@ high@ <)
                    -1 low!
                end

                0 high!
            end

            0x100000 low@ LDR_PC_MEMORY_FREE context@ func@ LdrPCMemoryFunc
        end

        if (high@)
            0xffffff high +=

            if (high@ 0xffffff <)
                -1 high!
            end

            0x1000000 high@ LDR_PC_MEMORY_FREE context@ func@ LdrPCMemoryFunc
        end

        return
    end

    regs@ LdrPCRegs_SIZEOF 0 memset
    0x8800 regs@ LdrPCRegs_eax + !
    0x15 regs@ LdrPCCallInterrupt

    if (regs@ LdrPCRegs_eflags + @ 1 & ~~)
        regs@ LdrPCRegs_eax + gi low!
        1024 low *=

        if (low@)
            0xfffff low +=

            LDR_PC_MEMORY_FREE low@ 0x100000 context@ func@ LdrPCMemoryFunc
        end
    end
end

// during build, LdrMemoryDescriptor fields are reused with different meanings as follows:
//  StartPFN: head
//  Pages: tail
//  OriginalExtent: prev

fn (LdrPCMemoryFunc) private LdrPCAddFreeRegion { head tail type context -- }
    if (type@ LDR_PC_MEMORY_FREE ~=)
        return
    end

    auto ldrtype
    OSLOADERMEM_FREE ldrtype!

    // mark physical ranges beyond KERNELSPACE as reclaiamble instead of free because the loader can't access those

    if (tail@ KERNELSPACE >=)
        if (head@ KERNELSPACE <)
            head@ KERNELSPACE 1 - type@ context@ LdrPCAddFreeRegion
            KERNELSPACE head!
        end

        OSLOADERMEM_RECLAIMABLE ldrtype!
    end

    // find insertion location (starting at the tail so that the common case of already-sorted is fast)

    auto prev
    context@ 4 + @ prev!

    auto next
    0 next!

    while (prev@)
        if (prev@ LdrMemoryDescriptor_StartPFN + @ head@ <)
            break
        end

        prev@ next!
        prev@ LdrMemoryDescriptor_OriginalExtent + @ prev!
    end

    // remove overlapping and neighboring followers

    while (next@)
        if (tail@ -1 < tail@ + 1 next@ LdrMemoryDescriptor_StartPFN + @ < &&)
            break
        end

        if (next@ LdrMemoryDescriptor_Pages + @ tail@ >)
            next@ LdrMemoryDescriptor_Pages + @ tail!
        end

        next@ LdrMemoryDescriptor_Next + @ next!

        if (prev@)
            next@ prev@ LdrMemoryDescriptor_Next + !
        end else
            next@ context@!
        end

        if (next@)
            prev@ next@ LdrMemoryDescriptor_OriginalExtent + !
        end else
            prev@ context@ 4 + !
        end
    end

    // merge with prev if possible

    if (prev@)
        if (prev@ LdrMemoryDescriptor_Pages + @ tail@ >=)
            return
        end

        if (prev@ LdrMemoryDescriptor_Type + @ ldrtype @ ==)
            tail@ prev@ LdrMemoryDescriptor_Pages + !
            return
        end
    end

    // create a new descriptor

	auto ok
	auto ldrdesc
	LdrMemoryDescriptor_SIZEOF // size
	LdrMemoryAllocate ok! ldrdesc!

	if (ok@)
		ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	end

    next@ ldrdesc@ LdrMemoryDescriptor_Next + !
    ldrtype@ ldrdesc@ LdrMemoryDescriptor_Type + !
    head@ ldrdesc@ LdrMemoryDescriptor_StartPFN + !
    tail@ ldrdesc@ LdrMemoryDescriptor_Pages + !
    prev@ ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !
    1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !

    // insert it

    if (prev@)
        ldrdesc@ prev@ LdrMemoryDescriptor_Next + !
    end else
        ldrdesc@ context@!
    end

    if (next@)
        ldrdesc@ next@ LdrMemoryDescriptor_OriginalExtent + !
    end else
        ldrdesc@ context@ 4 + !
    end
end

fn (LdrPCMemoryFunc) private LdrPCRemoveReservedRegion { head tail type context -- }
    if (type@ LDR_PC_MEMORY_FREE ==)
        return
    end

    // find location (starting at the tail so that the common case of already-sorted is fast)

    auto prev
    context@ 4 + @ prev!

    auto next
    0 next!

    while (prev@)
        if (prev@ LdrMemoryDescriptor_StartPFN + @ head@ <)
            break
        end

        prev@ next!
        prev@ LdrMemoryDescriptor_OriginalExtent + @ prev!
    end

    // remove overlapping parts of prev

    if (prev@)
        if (prev@ LdrMemoryDescriptor_Pages + @ tail@ >)
            // create a new descriptor

	        auto ok
	        auto ldrdesc
	        LdrMemoryDescriptor_SIZEOF // size
	        LdrMemoryAllocate ok! ldrdesc!

	        if (ok@)
	        	ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	        end

            next@ ldrdesc@ LdrMemoryDescriptor_Next + !
            prev@ LdrMemoryDescriptor_Type + @ ldrdesc@ LdrMemoryDescriptor_Type + !
            tail@ 1 + ldrdesc@ LdrMemoryDescriptor_StartPFN + !
            prev@ LdrMemoryDescriptor_Pages + @ ldrdesc@ LdrMemoryDescriptor_Pages + !
            prev@ ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !
            1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !

            // insert it

            ldrdesc@ prev@ LdrMemoryDescriptor_Next + !

            if (next@)
                ldrdesc@ next@ LdrMemoryDescriptor_OriginalExtent + !
            end else
                ldrdesc@ context@ 4 + !
            end

            ldrdesc@ next!
        end

        if (prev@ LdrMemoryDescriptor_Pages + @ head@ >=)
            head@ 1 - prev@ LdrMemoryDescriptor_Pages + !
        end
    end

    // remove overlapping parts of next until it doesn't overlap

    while (next@)
        if (tail@ next@ LdrMemoryDescriptor_StartPFN + @ <)
            break
        end

        if (tail@ next@ LdrMemoryDescriptor_Pages + @ <)
            tail@ 1 + next@ LdrMemoryDescriptor_StartPFN + !
            break
        end

        next@ LdrMemoryDescriptor_Next + @ next!

        if (prev@)
            next@ prev@ LdrMemoryDescriptor_Next + !
        end else
            next@ context@!
        end

        if (next@)
            prev@ next@ LdrMemoryDescriptor_OriginalExtent + !
        end else
            prev@ context@ 4 + !
        end
    end
end

const LDRINITIALHEAPSIZE 8192

fn private LdrPCBuildDescriptors { -- }
	// initialize the heap as an 8KB chunk at the end of low memory.

    auto regs
    LdrPCRegs_SIZEOF alloc regs!
    regs@ LdrPCRegs_SIZEOF 0 memset
    0x12 regs@ LdrPCCallInterrupt

    regs@ LdrPCRegs_eax + gi 10 << PAGENUMBERMASK & LdrHeapTop!
    LdrHeapTop@ LDRINITIALHEAPSIZE - LdrHeapPointer!

    if (LdrHeapPointer@ pointerof _bss_end <)
        "not enough memory for heap\n" LdrCrash
    end

    // build memory descriptors for low memory

    auto rtop
    pointerof _bss_end PAGEOFFSETMASK + PAGENUMBERMASK & rtop!

    auto hbottom
    LdrHeapPointer@ PAGENUMBERMASK & hbottom!

    auto htop
    LdrHeapTop@ PAGENUMBERMASK & htop!

    if (rtop@ hbottom@ >=)
        htop@ rtop!
        htop@ hbottom!
    end else
        hbottom@ LdrHeapPointer!
    end

    htop@ LdrMemoryTotalRAM +=

	auto ok
	auto ldrdesc

    // allocate the descriptor for the reclaimable memory range.

	LdrMemoryDescriptor_SIZEOF // size
	LdrMemoryAllocate ok! ldrdesc!

	if (ok@)
		ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	end

	0 ldrdesc@ LdrMemoryDescriptor_Next + !
	OSLOADERMEM_RECLAIMABLE ldrdesc@ LdrMemoryDescriptor_Type + !
	0 ldrdesc@ LdrMemoryDescriptor_StartPFN + !
	rtop@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_Pages + !

	1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !
	rtop@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

	ldrdesc@ LdrMemoryDescriptorListHead!
	ldrdesc@ LdrMemoryDescriptorListTail!

    // allocate the descriptor for the first free range.

	if (rtop@ hbottom@ <)
        LdrMemoryDescriptor_SIZEOF // size
	    LdrMemoryAllocate ok! ldrdesc!

	    if (ok@)
	    	ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	    end

	    0 ldrdesc@ LdrMemoryDescriptor_Next + !
	    OSLOADERMEM_FREE ldrdesc@ LdrMemoryDescriptor_Type + !
	    rtop@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_StartPFN + !
	    hbottom@ rtop@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_Pages + !

	    1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !
	    hbottom@ rtop@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

	    ldrdesc@ LdrMemoryDescriptorListTail@ LdrMemoryDescriptor_Next + !
	    ldrdesc@ LdrMemoryDescriptorListTail!
    end

    // allocate the descriptor for the first heap range.

    if (hbottom@ htop@ <)
	    LdrMemoryDescriptor_SIZEOF // size
	    LdrMemoryAllocate ok! ldrdesc!

	    if (ok@)
	    	ok@ "LdrPCBuildDescriptors: failed to allocate descriptor (%i)\n" LdrCrash
	    end

	    0 ldrdesc@ LdrMemoryDescriptor_Next + !
	    OSLOADERMEM_RECLAIMABLE ldrdesc@ LdrMemoryDescriptor_Type + !
	    hbottom@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_StartPFN + !
	    htop@ hbottom@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_Pages + !

	    1 ldrdesc@ LdrMemoryDescriptor_OriginalDescriptor + !
	    htop@ hbottom@ - PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

	    ldrdesc@ LdrMemoryDescriptorListTail@ LdrMemoryDescriptor_Next + !
	    ldrdesc@ LdrMemoryDescriptorListTail!
    end

    // build list of free regions in high memory

    auto highlist
    8 alloc highlist!
    0 highlist@!
    0 highlist@ 4 + !
    pointerof LdrPCAddFreeRegion highlist@ LdrPCIterateMemoryMap

    // remove reserved regions from list

    pointerof LdrPCRemoveReservedRegion highlist@ LdrPCIterateMemoryMap

    // convert temporary format to proper one

    highlist@@ ldrdesc!

    while (ldrdesc@)
        ldrdesc@ LdrMemoryDescriptor_Next + @ highlist!

        ldrdesc@ LdrMemoryDescriptor_StartPFN + @ hbottom!
        ldrdesc@ LdrMemoryDescriptor_Pages + @ htop!

        hbottom@ PAGEOFFSETMASK + PAGENUMBERMASK & ok!
        htop@ PAGEOFFSETMASK - PAGEOFFSETMASK | rtop!

        if (hbottom@ ok@ <= htop@ rtop@ >= && ok@ rtop@ <=)
            rtop@ ok@ - 1 + LdrMemoryTotalRAM +=

            0 ldrdesc@ LdrMemoryDescriptor_Next + !
            ok@ PAGESHIFT >> ldrdesc@ LdrMemoryDescriptor_StartPFN + !
            rtop@ ok@ - PAGESHIFT >> 1 + ldrdesc@ LdrMemoryDescriptor_Pages + !
            rtop@ ok@ - PAGESHIFT >> 1 + ldrdesc@ LdrMemoryDescriptor_OriginalExtent + !

            ldrdesc@ LdrMemoryDescriptorListTail@ LdrMemoryDescriptor_Next + !
            ldrdesc@ LdrMemoryDescriptorListTail!
        end

        highlist@ ldrdesc!
    end
end

extern LdrI386MapInit { -- }

fn LdrPlatformMemoryInit { -- }
    LdrPCBuildDescriptors

    // allocate a kernel space bitmap

    auto desc
    auto ok
    MANAGEDKERNELSPACESIZE PAGESHIFT >> 7 + 3 >> PAGEOFFSETMASK + PAGESHIFT >> // pages
    OSLOADERMEM_RECLAIMABLE // type
    LdrMemoryAllocatePhysicalRange ok! desc!

    if (ok@)
        "failed to allocate kernel space bitmap\n" LdrCrash
    end

    desc@ LdrMemoryDescriptor_StartPFN + @ PAGESHIFT << LdrKernelSpaceBitmap!

    // create IDENTITYSPACE and enable paging

    LdrI386MapInit
end

fn private LdrPCWriteChar { c -- }
    auto regs
    LdrPCRegs_SIZEOF alloc regs!
    regs@ LdrPCRegs_SIZEOF 0 memset
    0xe00 c@ | regs@ LdrPCRegs_eax + !
    0x7 regs@ LdrPCRegs_ebx + !
    0x10 regs@ LdrPCCallInterrupt
end

fn FPutc { fd c -- }
    if (c@ '\n' ==)
        '\r' LdrPCWriteChar
    end
    c@ 0xff & LdrPCWriteChar
end

fn FPuts { fd s -- }
    while (1)
        auto c
        s@ gb c!

        if (c@ ~~)
            break
        end

        fd@ c@ FPutc
        1 s +=
    end
end

fn Putc { c -- }
    1 c@ FPutc
end

fn Puts { s -- }
    1 s@ FPuts
end

fn VPrintf { argvt argcn fmt -- }
	argvt@ argcn@ fmt@ 1 VFPrintf
end

fn Malloc { size -- ptr }
    auto ok
    size@ LdrMemoryAllocate ok! ptr!

    if (ok)
        ERR ptr!
    end
end
